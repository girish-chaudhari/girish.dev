---
title: Multiple Reactions Feature
description: Building a multiple reactions feature ğŸ‘ğŸ˜²ğŸ§ in Next.js (MongoDB, Prisma, SWR)
date: '2023-01-15'
lang: en
tags:
  - features
  - concept
category: features
---

import IH from '@/components/mdx/InlineHighlight';
import Reactions from '@/components/Reactions';

[TL;DR](#final-result)

I didnâ€™t expect building this would take almost three days, but everything was built from scratch. **JUST** making the reactions feature, yes the one you see below ğŸ˜

No **analysis** beforehand, just jumped into creating the database, trial & error, and refactoring. Somewhere between â€œdonâ€™t know howâ€ and â€œtoo lazy,â€ but mostly I just wanted to start coding ğŸ˜‚

In this article, Iâ€™ll explain what features I built, the concept behind itâ€”but not a step-by-step tutorial.

Maybe some of you want to build the same thing, so feel free to copy bits here and there, just make sure to take the **good parts** only, okay?

Letâ€™s go...

---

## Features

First I thought of a rough idea of what this reaction feature should look like.

And hereâ€™s what I came up with:

- **Multiple Reactions**

  There are <IH>claps</IH>, <IH color="blue">wow</IH>, etc., and it should be easy to add more types in the future.

  <br />

- **Batch Reactions**

  Able to give multiple reactions of the same type, e.g. 20x <IH>claps</IH>, 10x <IH color="blue">wow</IH>, etc.

  <br />

- **Section Reactions**

  Able to know where the user gave the reaction, for example, 10x <IH>claps</IH> on the section titled **'Features'**, like this section.

  <br />

---

## Concept

What took the longest was building the REST API, a lot of refactoring, setting up the database schema, and other backend-related things.

A lot might not be ideal, please understandâ€”I'm not a backend engineer âœŒ

### Database

Honestly, after three years Iâ€™m back working with databases again. The last time was during my final university project.

First, I decided where to host. SQL vs NoSQL didnâ€™t matter, I just wanted something free to try. I found **MongoDB Atlas** (shared) hosting, which was good enough.

I also used **prisma** as the ORM, so migrating to another DB later shouldnâ€™t be too hard.

Letâ€™s go to the schema. Iâ€™ll focus on the reactions feature only. There are also fields for views and shares, but I intentionally left them out here.

First, I created a **ContentMeta** table to store post metadata.

No need to store title, date, content, etc., since all that is built locally from mdx. So, I just store the slug.

```scheme {4}
model ContentMeta {
  id          String

  slug        String
  createdAt   DateTime
}
```

Then comes the important one, the **Reaction** table, to store all the **reactions**.

```scheme {4-7}
model Reaction {
  id          String

  type        ReactionType
  section     String
  count       Int
  sessionId   String
  createdAt   DateTime

  contentId   String
}

enum ReactionType {
  CLAPPING
  THINKING
  AMAZED
}
```

Letâ€™s break it down slowly:

- `type`

  Very important, because we have multiple reactions, so `type` is mandatory. I used a predefined enum `ReactionType`, so the values are limited to `CLAPPING`, `THINKING`, and `AMAZED`.

  If you want to add more, just update the enum. Alternatively, change the type to `String` to allow any emoji-based reaction.

  > Why not create a new relation table?

  You can, but I thought that would make querying harder. Enums are sufficient here and give us type safety âœŒ

  <br />

- `section`

  Just stores the title of the section that was active when the user clicked the reaction. For example, if the user was on the 'Database' section, then this would store 'database'.

  It uses [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) to observe all section titles. The last one to be '**isIntersecting**' is saved as the section.

  <br />

- `count`

  This holds the batch reaction count. So clicking a reaction doesnâ€™t immediately send a request, it waits a few milliseconds using [debounce](https://www.freecodecamp.org/news/javascript-debounce-example/).

  Simply put: when you click several times quickly (say 10 clicks), it gathers them, then sends one API request and saves the count as 10.

  This makes more sense to me than sending 10 API requests and storing 10 identical rows. Also helps conserve database space.

  <br />

- `sessionId`

  To store _who_ reacted. Not user identity or name, I use the IP address.

  But not in plain formâ€”since IPs are sensitiveâ€”I hash the address and add a **salt** for extra security. So no one (even me) can read the userâ€™s IP.

  Hereâ€™s roughly how:

  ```ts
  export const getSessionId = (req: NextApiRequest) => {
    const ipAddress = req.headers['x-forwarded-for'] || 'localhost';

    const currentSessionId = createHash('md5')
      .update(ipAddress + process.env.SALT_IP_ADDRESS, 'utf-8')
      .digest('hex');

    return currentSessionId;
  };
  ```

  Or inspect the code directly [here](https://github.com/enjidev/enji.dev/blob/425e3c09c906c005a7e1d9efbf21b87906ffd443/apps/enji.dev/src/helpers/server.ts).

  > So why is sessionId needed?

  It's used to **limit** the number of reactions. I groupBy `type` where `sessionId`, then calculate the `count`.

  If it hits the limit, the user canâ€™t react anymore.

  <br />

---

### REST API

Only needs one endpoint: `/reactions`, which accepts POST requests. The data it receives: `slug`, `type`, `section`, and `count`.

As explained, the front-end handles all this data except `sessionId`, which is generated during the API request.

Actually, one more endpoint: GET `/content`. It returns current reaction counts by `slug`, to be used in the component.

From the two tables, we get this data (`/content` response):

```JSON
{
  "meta": {
    "reactionsDetail": {
      "CLAPPING": 65,
      "THINKING": 45,
      "AMAZED": 48
    }
  },
  "metaUser": {
    "reactionsDetail": {
      "CLAPPING": 15,
      "THINKING": 15,
      "AMAZED": 15
    }
  },
  "metaSection": {
    "features": {
      "reactionsDetail": {
        "CLAPPING": 0,
        "THINKING": 4,
        "AMAZED": 0
      }
    },
    "database": {
      "reactionsDetail": {
        "CLAPPING": 0,
        "THINKING": 0,
        "AMAZED": 6
      }
    },
  }
}
```

`meta` is total reactions from all users, `metaUser` is the current userâ€™s reactions, and `metaSection` is for reactions on specific sections.

You might askâ€”why not make `metaSection` an array?

Honestly... no idea ğŸ˜‚

But since in FE my logic only fetches one section, I prefer `metaSection[section]` over filtering an array ğŸ‘€

---

### Component

**This is the part that I enjoy the most.**

I used SWR to fetch API data. As SWR's site says:

> With SWR, components will get a stream of data updates constantly and automatically. And the UI will be always fast and reactive.

Itâ€™s really convenient, especially for mutations.

---

Now letâ€™s build the reactions component ğŸ¥³

Component details:

1. Shows emoji reactions like `claps`, `wow`, and `hmm`.
2. Animates emoji on hover.
3. Shows animation on batch or multi-clicks.
4. Adds animation to the reactions counter.
5. Changes emoji when hitting limit.

Emoji animations (point 2) are from [here](https://animated-fluent-emoji.vercel.app/).

---

For animations, I still use framer motion ğŸ˜

When a user clicks, we animate using random `x` and `y` values. These values are rendered with framer motion.

So, each click animation appears in a different directionâ€”not monotonous.

Confusing? Hehe sorryâ€”check [the full code](https://github.com/enjidev/enji.dev/blob/425e3c09c906c005a7e1d9efbf21b87906ffd443/apps/enji.dev/src/components/EmojiReaction.tsx).

---

## Final Result

Hereâ€™s the resultâ€”try giving reactions till the limit, youâ€™ll see the animations ğŸ˜

<div
  style={{
    maxWidth: '360px',
    margin: 'auto',
    marginTop: '32px',
    marginBottom: '32px',
  }}
>
  <Reactions withCountView={false} />
</div>

Though the visuals, images, layout, and performance still need tweaking, Iâ€™m happy with the current result.

---

## Summary

Although building this feature was quite challenging, especially the backend, I really enjoyed the process. Even if it took almost three days ğŸ˜

Recap of tech stack/libraries used:

- [MongoDB Atlas](https://www.mongodb.com/pricing) for database hosting.
- [Prisma](https://www.prisma.io/) as ORM.
- [SWR](https://swr.vercel.app/) for data fetching.
- [Framer Motion](https://www.framer.com/motion/) for animations.
- [Animated Fluent Emoji](https://animated-fluent-emoji.vercel.app/)

---

> WAIT, and that **section reactions**? The API gives `metaSection`, but how is it used?

The dataâ€™s ready, implementation pending. But I already have plans and a mental image of how itâ€™ll be used. Just wait ğŸ˜

Updates will probably come via [Twitter](https://twitter.com/enjidev), not a full blog post.

**THANK YOU** for reading all the way to the end. See you next week in the next post ğŸ‘‹
